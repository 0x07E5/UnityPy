<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>UnityPy.helpers.TypeTreeHelper API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>UnityPy.helpers.TypeTreeHelper</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from ..streams import EndianBinaryReader


class RefInt:
    v: int

    def __init__(self, value):
        self._value = value

    def __add__(self, other):
        return self._value + other

    def __sub__(self, other):
        self._value -= other
        return self._value

    def __int__(self):
        return self._value

    def __getattr__(self, item):
        return self._value

    def __getitem__(self, item):
        return self._value

    def __setattr__(self, key, value):
        self.__dict__[&#34;_value&#34;] = value

    def __setitem__(self, key, value):
        self._value = value

    def __mod__(self, other):
        return self._value % other

    def __ge__(self, other):
        return self._value &gt;= other

    def __gt__(self, other):
        return self._value &gt; other

    def __le__(self, other):
        return self._value &lt;= other

    def __lt__(self, other):
        return self._value &lt; other

    def __eq__(self, other):
        return self._value == other


def get_members(members: list, level: int, index: int) -&gt; list:
    member2 = [members[0]]
    for i in range(index + 1, len(members)):
        member = members[i]
        if member.level &lt;= level:
            return member2
        member2.append(member)
    return member2


class TypeTreeHelper:
    def __init__(self, reader: EndianBinaryReader):
        self.reader = reader
        self.READ = {
            &#34;SInt8&#34;: self.reader.read_byte,
            &#34;UInt8&#34;: self.reader.read_u_byte,
            &#34;short&#34;: self.reader.read_short,
            &#34;SInt16&#34;: self.reader.read_short,
            &#34;unsigned short&#34;: self.reader.read_u_short,
            &#34;UInt16&#34;: self.reader.read_u_short,
            &#34;int&#34;: self.reader.read_int,
            &#34;SInt32&#34;: self.reader.read_int,
            &#34;unsigned int&#34;: self.reader.read_u_int,
            &#34;UInt32&#34;: self.reader.read_u_int,
            &#34;Type*&#34;: self.reader.read_u_int,
            &#34;long long&#34;: self.reader.read_long,
            &#34;SInt64&#34;: self.reader.read_long,
            &#34;unsigned long long&#34;: self.reader.read_u_long,
            &#34;UInt64&#34;: self.reader.read_u_long,
            &#34;float&#34;: self.reader.read_float,
            &#34;double&#34;: self.reader.read_double,
            &#34;bool&#34;: self.reader.read_boolean,
        }

        self.READ2 = {
            &#34;string&#34;: self.read_string,
            &#34;map&#34;: self.read_map,
            &#34;TypelessData&#34;: self.read_typeless_data,
        }

    def read_u_type(self, members: list) -&gt; dict:
        i = RefInt(0)
        obj = {}
        while i.v &lt; len(members):
            member = members[i.v]
            obj[member.name] = self.read_value(members, i)
            i.v += 1
        return obj

    def read_string(self, i, align, *args):
        value = self.reader.read_aligned_string()
        i.v += 3
        return value, align

    def read_map(self, i, align, members, level):
        if (members[i + 1].meta_flag &amp; 0x4000) != 0:
            align = True
        size = self.reader.read_int()
        map_ = get_members(members, level, i)[4:]
        i.v += len(map_) + 3
        first = get_members(map_, map_[0].level, 0)
        second = map_[len(first) :]
        value = {}
        for j in range(size):
            tmp1 = RefInt(0)
            tmp2 = RefInt(0)
            v1 = self.read_value(
                first, tmp1
            )  # python reads the value first and then the key, so it has to be this way
            if isinstance(v1, dict):
                value[first] = tmp1
                value[&#34;values&#34;] = self.read_value(second, tmp2)
            else:
                value[v1] = self.read_value(second, tmp2)
        return value, align

    def read_typeless_data(self, i, align, *args):
        size = self.reader.read_int()
        value = self.reader.read_bytes(size)
        i.v += 2
        return value, align

    def read_value(self, members: list, _i) -&gt; object:
        i = RefInt(_i) if type(_i) != RefInt else _i
        member = members[i.v]
        level = member.level
        var_type_str = member.type
        align = (member.meta_flag &amp; 0x4000) != 0

        value = self.READ.get(var_type_str)
        if value:
            value = value()
        else:
            value = self.READ2.get(var_type_str)
            if value:
                value, align = value(i, align, members, level)
            else:
                if i != len(members) and members[i.v + 1].type == &#34;Array&#34;:
                    if (members[i.v + 1].meta_flag &amp; 0x4000) != 0:
                        align = True
                    size = self.reader.read_int()
                    vector = get_members(members, level, i)[3:]
                    i.v += len(vector) + 2
                    value = [self.read_value(vector, 0) for _ in range(size)]
                else:
                    eclass = get_members(members, level, i)
                    eclass.pop(0)
                    i.v += len(eclass)
                    j = RefInt(0)
                    value = {}
                    while j &lt; len(eclass):
                        classmember = eclass[j.v]
                        name = classmember.name
                        value[name] = self.read_value(eclass, j)
                        j.v += 1
        if align:
            self.reader.align_stream()
        return value

    def read_type_string(self, sb: list, members: list):
        i = RefInt(0)
        while i &lt; len(members):
            self.read_string_value(sb, members, i)
            i.v += 1
        return sb

    def read_string_value(self, sb: list, members, i: RefInt):
        if type(i) != RefInt:
            i = RefInt(i)
        member = members[i.v]
        level = member.level
        var_type_str = member.type
        var_name_str = member.name
        append = True
        align = (member.meta_flag &amp; 0x4000) != 0
        value = self.READ.get(var_type_str)
        if value:
            value = value()

        elif var_type_str == &#34;string&#34;:
            append = False
            string = self.reader.read_aligned_string()
            sb.append(
                &#39;{0}{1} {2} = &#34;{3}&#34;\r\n&#39;.format(
                    &#34;\t&#34; * level, var_type_str, var_name_str, string
                )
            )
            i.v += 3

        elif var_type_str == &#34;vector&#34;:
            if (members[i + 1].meta_flag &amp; 0x4000) != 0:
                align = True
            append = False
            sb.append(&#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * level, var_type_str, var_name_str))
            sb.append(&#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * (level + 1), &#34;Array&#34;, &#34;Array&#34;))
            size = self.reader.read_int()
            sb.append(
                &#34;{0}{1} {2} = {3}\r\n&#34;.format(&#34;\t&#34; * (level + 1), &#34;int&#34;, &#34;size&#34;, size)
            )
            vector = get_members(members, level, i.v)[3:]
            i.v += len(vector) + 2
            for j in range(size):
                sb.append(&#34;{0}[{1}]\r\n&#34;.format(&#34;\t&#34; * (level + 2), j))
                tmp = RefInt(0)
                self.read_string_value(sb, vector, tmp)

        elif var_type_str == &#34;map&#34;:
            if (members[i + 1].meta_flag &amp; 0x4000) != 0:
                align = True
            append = False
            sb.append(&#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * level, var_type_str, var_name_str))
            sb.append(&#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * (level + 1), &#34;Array&#34;, &#34;Array&#34;))
            size = self.reader.read_int()
            sb.append(
                &#34;{0}{1} {2} = {3}\r\n&#34;.format(&#34;\t&#34; * (level + 1), &#34;int&#34;, &#34;size&#34;, size)
            )
            map_ = get_members(members, level, i.v)[4:]
            i.v += len(map_) + 3
            first = get_members(map_, map_[0].level, 0)
            second = map_[len(first) :]
            for j in range(size):
                sb.append(&#34;{0}[{1}]\r\n&#34;.format(&#34;\t&#34; * (level + 2), j))
                sb.append(&#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * (level + 2), &#34;pair&#34;, &#34;data&#34;))
                tmp1 = RefInt(0)
                tmp2 = RefInt(0)
                self.read_string_value(sb, first, tmp1)
                self.read_string_value(sb, second, tmp2)

        elif var_type_str == &#34;TypelessData&#34;:
            append = False
            size = self.reader.read_int()
            value = self.reader.read_bytes(size)
            i.v += 2
            sb.append(&#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * level, var_type_str, var_name_str))
            sb.append(&#34;{0}{1} {2} = {3}\r\n&#34;.format(&#34;\t&#34; * level, &#34;int&#34;, &#34;size&#34;, size))

        else:
            if i != len(members) and members[i + 1].type == &#34;Array&#34;:
                if (members[i + 1].meta_flag &amp; 0x4000) != 0:
                    align = True
                append = False
                sb.append(
                    &#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * level, var_type_str, var_name_str)
                )
                sb.append(&#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * (level + 1), &#34;Array&#34;, &#34;Array&#34;))
                size = self.reader.read_int()
                sb.append(
                    &#34;{0}{1} {2} = {3}\r\n&#34;.format(
                        &#34;\t&#34; * (level + 1), &#34;int&#34;, &#34;size&#34;, size
                    )
                )
                vector = get_members(members, level, i.v)
                i.v += len(vector) - 1
                vector = vector[3:]  # vector.RemoveRange(0, 3)
                for j in range(size):
                    sb.append(&#34;{0}[{1}]\r\n&#34;.format(&#34;\t&#34; * (level + 2), j))
                    tmp = RefInt(0)
                    self.read_string_value(sb, vector, tmp)
            else:
                append = False
                sb.append(
                    &#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * level, var_type_str, var_name_str)
                )
                eclass = get_members(members, level, i.v)
                eclass.pop(0)  # .RemoveAt(0)
                i.v += len(eclass)
                j = RefInt(0)
                while j &lt; len(eclass):
                    self.read_string_value(sb, eclass, j)
                    j.v += 1

        if append:
            sb.append(
                &#34;{0}{1} {2} = {3}\r\n&#34;.format(
                    &#34;\t&#34; * level, var_type_str, var_name_str, value
                )
            )
        if align:
            self.reader.align_stream()

        return sb


&#34;&#34;&#34;
        def write_u_type(self, obj: dict, members: list) -&gt; bytes:
                stream = io.BytesIO()
                write = EndianBinaryReader(stream)
                for i, member in enumerate(members):
                        var_name_str = member.name
                        write_value(obj[var_name_str], members, write, RefInt(i))
                pos = stream.tell()
                stream.seek(0)
                ret = stream.read()
                stream.seek(pos)
                return ret

        def write_value(value: dict, members: list, write: EndianBinaryReader, i):
                member = members[i.v]
                level = member.level
                var_type_str = member.type
                align = (member.meta_flag &amp; 0x4000) != 0
                if var_type_str == &#34;SInt8&#34;:
                        write.write_s_byte(value)
                elif var_type_str == &#34;UInt8&#34;:
                        write.write_byte(value)
                elif var_type_str in [&#34;short&#34;, &#34;SInt16&#34;]:
                        write.write_short(value)
                elif var_type_str in [&#34;UInt16&#34;, &#34;unsigned short&#34;]:
                        write.write_u_short(value)
                elif var_type_str in [&#34;int&#34;, &#34;SInt32&#34;]:
                        write.write_int(value)
                elif var_type_str in [&#34;UInt32&#34;, &#34;unsigned int&#34;, &#34;Type*&#34;]:
                        write.write_u_int(value)
                elif var_type_str in [&#34;long long&#34;, &#34;SInt64&#34;]:
                        write.write_long(value)
                elif var_type_str in [&#34;UInt64&#34;, &#34;unsigned long long&#34;]:
                        write.write_u_long(value)
                elif var_type_str == &#34;float&#34;:
                        write.write_float(value)
                elif var_type_str == &#34;double&#34;:
                        write.write_double(value)
                elif var_type_str == &#34;bool&#34;:
                        write.write_bool(value)
                elif var_type_str == &#34;string&#34;:
                        write.write_aligned_string(value)
                        i.v += 3
                elif var_type_str == &#34;map&#34;:
                        if (members[i + 1].meta_flag &amp; 0x4000) != 0:
                                align = True
                        dic = list(value.items())
                        size = len(dic)
                        write.Write(size)
                        map_ = get_members(members, level, i)
                        i.v += len(map_) - 1
                        map_ = map_[4:]  # map.RemoveRange(0, 4)
                        first = get_members(map_, map_[0].level, 0)
                        map_ = map_[len(first):]  # .RemoveRange(0, len(first))
                        second = map_
                        for j in range(size):
                                tmp1 = RefInt(0)
                                tmp2 = RefInt(0)
                                write_value(dic[j][0], first, write, tmp1)  # key
                                write_value(dic[j][1], second, write, tmp2)  # value
                elif var_type_str == &#34;TypelessData&#34;:
                        byts = bytes(value)
                        size = len(byts)
                        write.Write(size)
                        write.Write(bytes)
                        i.v += 2
                else:
                        if i != len(members) and members[i + 1].type == &#34;Array&#34;:  # Array
                                if (members[i.v + 1].meta_flag &amp; 0x4000) != 0:
                                        align = True
                                list_ = value
                                size = len(list_)
                                write.Write(size)
                                vector = get_members(members, level, i)
                                i.v += len(vector) - 1
                                vector = vector[3:]  # vector.RemoveRange(0, 3)
                                for j in range(size):
                                        tmp = RefInt(0)
                                        write_value(list_[j], vector, write, tmp)
                        else:  # Class
                                eclass = get_members(members, level, i)
                                eclass.pop(0)  # .RemoveAt(0)
                                i.v += len(eclass)
                                obj = value
                                j = RefInt(0)
                                while j &lt; len(eclass):
                                        classmember = eclass[j.v]
                                        name = classmember.name
                                        write_value(obj[name], eclass, write, j)
                if align:
                        write.align_stream(4)


&#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="UnityPy.helpers.TypeTreeHelper.get_members"><code class="name flex">
<span>def <span class="ident">get_members</span></span>(<span>members: list, level: int, index: int) ‑> list</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_members(members: list, level: int, index: int) -&gt; list:
    member2 = [members[0]]
    for i in range(index + 1, len(members)):
        member = members[i]
        if member.level &lt;= level:
            return member2
        member2.append(member)
    return member2</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="UnityPy.helpers.TypeTreeHelper.RefInt"><code class="flex name class">
<span>class <span class="ident">RefInt</span></span>
<span>(</span><span>value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RefInt:
    v: int

    def __init__(self, value):
        self._value = value

    def __add__(self, other):
        return self._value + other

    def __sub__(self, other):
        self._value -= other
        return self._value

    def __int__(self):
        return self._value

    def __getattr__(self, item):
        return self._value

    def __getitem__(self, item):
        return self._value

    def __setattr__(self, key, value):
        self.__dict__[&#34;_value&#34;] = value

    def __setitem__(self, key, value):
        self._value = value

    def __mod__(self, other):
        return self._value % other

    def __ge__(self, other):
        return self._value &gt;= other

    def __gt__(self, other):
        return self._value &gt; other

    def __le__(self, other):
        return self._value &lt;= other

    def __lt__(self, other):
        return self._value &lt; other

    def __eq__(self, other):
        return self._value == other</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="UnityPy.helpers.TypeTreeHelper.RefInt.v"><code class="name">var <span class="ident">v</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="UnityPy.helpers.TypeTreeHelper.TypeTreeHelper"><code class="flex name class">
<span>class <span class="ident">TypeTreeHelper</span></span>
<span>(</span><span>reader: <a title="UnityPy.streams.EndianBinaryReader.EndianBinaryReader" href="../streams/EndianBinaryReader.html#UnityPy.streams.EndianBinaryReader.EndianBinaryReader">EndianBinaryReader</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypeTreeHelper:
    def __init__(self, reader: EndianBinaryReader):
        self.reader = reader
        self.READ = {
            &#34;SInt8&#34;: self.reader.read_byte,
            &#34;UInt8&#34;: self.reader.read_u_byte,
            &#34;short&#34;: self.reader.read_short,
            &#34;SInt16&#34;: self.reader.read_short,
            &#34;unsigned short&#34;: self.reader.read_u_short,
            &#34;UInt16&#34;: self.reader.read_u_short,
            &#34;int&#34;: self.reader.read_int,
            &#34;SInt32&#34;: self.reader.read_int,
            &#34;unsigned int&#34;: self.reader.read_u_int,
            &#34;UInt32&#34;: self.reader.read_u_int,
            &#34;Type*&#34;: self.reader.read_u_int,
            &#34;long long&#34;: self.reader.read_long,
            &#34;SInt64&#34;: self.reader.read_long,
            &#34;unsigned long long&#34;: self.reader.read_u_long,
            &#34;UInt64&#34;: self.reader.read_u_long,
            &#34;float&#34;: self.reader.read_float,
            &#34;double&#34;: self.reader.read_double,
            &#34;bool&#34;: self.reader.read_boolean,
        }

        self.READ2 = {
            &#34;string&#34;: self.read_string,
            &#34;map&#34;: self.read_map,
            &#34;TypelessData&#34;: self.read_typeless_data,
        }

    def read_u_type(self, members: list) -&gt; dict:
        i = RefInt(0)
        obj = {}
        while i.v &lt; len(members):
            member = members[i.v]
            obj[member.name] = self.read_value(members, i)
            i.v += 1
        return obj

    def read_string(self, i, align, *args):
        value = self.reader.read_aligned_string()
        i.v += 3
        return value, align

    def read_map(self, i, align, members, level):
        if (members[i + 1].meta_flag &amp; 0x4000) != 0:
            align = True
        size = self.reader.read_int()
        map_ = get_members(members, level, i)[4:]
        i.v += len(map_) + 3
        first = get_members(map_, map_[0].level, 0)
        second = map_[len(first) :]
        value = {}
        for j in range(size):
            tmp1 = RefInt(0)
            tmp2 = RefInt(0)
            v1 = self.read_value(
                first, tmp1
            )  # python reads the value first and then the key, so it has to be this way
            if isinstance(v1, dict):
                value[first] = tmp1
                value[&#34;values&#34;] = self.read_value(second, tmp2)
            else:
                value[v1] = self.read_value(second, tmp2)
        return value, align

    def read_typeless_data(self, i, align, *args):
        size = self.reader.read_int()
        value = self.reader.read_bytes(size)
        i.v += 2
        return value, align

    def read_value(self, members: list, _i) -&gt; object:
        i = RefInt(_i) if type(_i) != RefInt else _i
        member = members[i.v]
        level = member.level
        var_type_str = member.type
        align = (member.meta_flag &amp; 0x4000) != 0

        value = self.READ.get(var_type_str)
        if value:
            value = value()
        else:
            value = self.READ2.get(var_type_str)
            if value:
                value, align = value(i, align, members, level)
            else:
                if i != len(members) and members[i.v + 1].type == &#34;Array&#34;:
                    if (members[i.v + 1].meta_flag &amp; 0x4000) != 0:
                        align = True
                    size = self.reader.read_int()
                    vector = get_members(members, level, i)[3:]
                    i.v += len(vector) + 2
                    value = [self.read_value(vector, 0) for _ in range(size)]
                else:
                    eclass = get_members(members, level, i)
                    eclass.pop(0)
                    i.v += len(eclass)
                    j = RefInt(0)
                    value = {}
                    while j &lt; len(eclass):
                        classmember = eclass[j.v]
                        name = classmember.name
                        value[name] = self.read_value(eclass, j)
                        j.v += 1
        if align:
            self.reader.align_stream()
        return value

    def read_type_string(self, sb: list, members: list):
        i = RefInt(0)
        while i &lt; len(members):
            self.read_string_value(sb, members, i)
            i.v += 1
        return sb

    def read_string_value(self, sb: list, members, i: RefInt):
        if type(i) != RefInt:
            i = RefInt(i)
        member = members[i.v]
        level = member.level
        var_type_str = member.type
        var_name_str = member.name
        append = True
        align = (member.meta_flag &amp; 0x4000) != 0
        value = self.READ.get(var_type_str)
        if value:
            value = value()

        elif var_type_str == &#34;string&#34;:
            append = False
            string = self.reader.read_aligned_string()
            sb.append(
                &#39;{0}{1} {2} = &#34;{3}&#34;\r\n&#39;.format(
                    &#34;\t&#34; * level, var_type_str, var_name_str, string
                )
            )
            i.v += 3

        elif var_type_str == &#34;vector&#34;:
            if (members[i + 1].meta_flag &amp; 0x4000) != 0:
                align = True
            append = False
            sb.append(&#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * level, var_type_str, var_name_str))
            sb.append(&#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * (level + 1), &#34;Array&#34;, &#34;Array&#34;))
            size = self.reader.read_int()
            sb.append(
                &#34;{0}{1} {2} = {3}\r\n&#34;.format(&#34;\t&#34; * (level + 1), &#34;int&#34;, &#34;size&#34;, size)
            )
            vector = get_members(members, level, i.v)[3:]
            i.v += len(vector) + 2
            for j in range(size):
                sb.append(&#34;{0}[{1}]\r\n&#34;.format(&#34;\t&#34; * (level + 2), j))
                tmp = RefInt(0)
                self.read_string_value(sb, vector, tmp)

        elif var_type_str == &#34;map&#34;:
            if (members[i + 1].meta_flag &amp; 0x4000) != 0:
                align = True
            append = False
            sb.append(&#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * level, var_type_str, var_name_str))
            sb.append(&#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * (level + 1), &#34;Array&#34;, &#34;Array&#34;))
            size = self.reader.read_int()
            sb.append(
                &#34;{0}{1} {2} = {3}\r\n&#34;.format(&#34;\t&#34; * (level + 1), &#34;int&#34;, &#34;size&#34;, size)
            )
            map_ = get_members(members, level, i.v)[4:]
            i.v += len(map_) + 3
            first = get_members(map_, map_[0].level, 0)
            second = map_[len(first) :]
            for j in range(size):
                sb.append(&#34;{0}[{1}]\r\n&#34;.format(&#34;\t&#34; * (level + 2), j))
                sb.append(&#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * (level + 2), &#34;pair&#34;, &#34;data&#34;))
                tmp1 = RefInt(0)
                tmp2 = RefInt(0)
                self.read_string_value(sb, first, tmp1)
                self.read_string_value(sb, second, tmp2)

        elif var_type_str == &#34;TypelessData&#34;:
            append = False
            size = self.reader.read_int()
            value = self.reader.read_bytes(size)
            i.v += 2
            sb.append(&#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * level, var_type_str, var_name_str))
            sb.append(&#34;{0}{1} {2} = {3}\r\n&#34;.format(&#34;\t&#34; * level, &#34;int&#34;, &#34;size&#34;, size))

        else:
            if i != len(members) and members[i + 1].type == &#34;Array&#34;:
                if (members[i + 1].meta_flag &amp; 0x4000) != 0:
                    align = True
                append = False
                sb.append(
                    &#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * level, var_type_str, var_name_str)
                )
                sb.append(&#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * (level + 1), &#34;Array&#34;, &#34;Array&#34;))
                size = self.reader.read_int()
                sb.append(
                    &#34;{0}{1} {2} = {3}\r\n&#34;.format(
                        &#34;\t&#34; * (level + 1), &#34;int&#34;, &#34;size&#34;, size
                    )
                )
                vector = get_members(members, level, i.v)
                i.v += len(vector) - 1
                vector = vector[3:]  # vector.RemoveRange(0, 3)
                for j in range(size):
                    sb.append(&#34;{0}[{1}]\r\n&#34;.format(&#34;\t&#34; * (level + 2), j))
                    tmp = RefInt(0)
                    self.read_string_value(sb, vector, tmp)
            else:
                append = False
                sb.append(
                    &#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * level, var_type_str, var_name_str)
                )
                eclass = get_members(members, level, i.v)
                eclass.pop(0)  # .RemoveAt(0)
                i.v += len(eclass)
                j = RefInt(0)
                while j &lt; len(eclass):
                    self.read_string_value(sb, eclass, j)
                    j.v += 1

        if append:
            sb.append(
                &#34;{0}{1} {2} = {3}\r\n&#34;.format(
                    &#34;\t&#34; * level, var_type_str, var_name_str, value
                )
            )
        if align:
            self.reader.align_stream()

        return sb</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="UnityPy.helpers.TypeTreeHelper.TypeTreeHelper.read_map"><code class="name flex">
<span>def <span class="ident">read_map</span></span>(<span>self, i, align, members, level)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_map(self, i, align, members, level):
    if (members[i + 1].meta_flag &amp; 0x4000) != 0:
        align = True
    size = self.reader.read_int()
    map_ = get_members(members, level, i)[4:]
    i.v += len(map_) + 3
    first = get_members(map_, map_[0].level, 0)
    second = map_[len(first) :]
    value = {}
    for j in range(size):
        tmp1 = RefInt(0)
        tmp2 = RefInt(0)
        v1 = self.read_value(
            first, tmp1
        )  # python reads the value first and then the key, so it has to be this way
        if isinstance(v1, dict):
            value[first] = tmp1
            value[&#34;values&#34;] = self.read_value(second, tmp2)
        else:
            value[v1] = self.read_value(second, tmp2)
    return value, align</code></pre>
</details>
</dd>
<dt id="UnityPy.helpers.TypeTreeHelper.TypeTreeHelper.read_string"><code class="name flex">
<span>def <span class="ident">read_string</span></span>(<span>self, i, align, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_string(self, i, align, *args):
    value = self.reader.read_aligned_string()
    i.v += 3
    return value, align</code></pre>
</details>
</dd>
<dt id="UnityPy.helpers.TypeTreeHelper.TypeTreeHelper.read_string_value"><code class="name flex">
<span>def <span class="ident">read_string_value</span></span>(<span>self, sb: list, members, i: <a title="UnityPy.helpers.TypeTreeHelper.RefInt" href="#UnityPy.helpers.TypeTreeHelper.RefInt">RefInt</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_string_value(self, sb: list, members, i: RefInt):
    if type(i) != RefInt:
        i = RefInt(i)
    member = members[i.v]
    level = member.level
    var_type_str = member.type
    var_name_str = member.name
    append = True
    align = (member.meta_flag &amp; 0x4000) != 0
    value = self.READ.get(var_type_str)
    if value:
        value = value()

    elif var_type_str == &#34;string&#34;:
        append = False
        string = self.reader.read_aligned_string()
        sb.append(
            &#39;{0}{1} {2} = &#34;{3}&#34;\r\n&#39;.format(
                &#34;\t&#34; * level, var_type_str, var_name_str, string
            )
        )
        i.v += 3

    elif var_type_str == &#34;vector&#34;:
        if (members[i + 1].meta_flag &amp; 0x4000) != 0:
            align = True
        append = False
        sb.append(&#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * level, var_type_str, var_name_str))
        sb.append(&#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * (level + 1), &#34;Array&#34;, &#34;Array&#34;))
        size = self.reader.read_int()
        sb.append(
            &#34;{0}{1} {2} = {3}\r\n&#34;.format(&#34;\t&#34; * (level + 1), &#34;int&#34;, &#34;size&#34;, size)
        )
        vector = get_members(members, level, i.v)[3:]
        i.v += len(vector) + 2
        for j in range(size):
            sb.append(&#34;{0}[{1}]\r\n&#34;.format(&#34;\t&#34; * (level + 2), j))
            tmp = RefInt(0)
            self.read_string_value(sb, vector, tmp)

    elif var_type_str == &#34;map&#34;:
        if (members[i + 1].meta_flag &amp; 0x4000) != 0:
            align = True
        append = False
        sb.append(&#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * level, var_type_str, var_name_str))
        sb.append(&#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * (level + 1), &#34;Array&#34;, &#34;Array&#34;))
        size = self.reader.read_int()
        sb.append(
            &#34;{0}{1} {2} = {3}\r\n&#34;.format(&#34;\t&#34; * (level + 1), &#34;int&#34;, &#34;size&#34;, size)
        )
        map_ = get_members(members, level, i.v)[4:]
        i.v += len(map_) + 3
        first = get_members(map_, map_[0].level, 0)
        second = map_[len(first) :]
        for j in range(size):
            sb.append(&#34;{0}[{1}]\r\n&#34;.format(&#34;\t&#34; * (level + 2), j))
            sb.append(&#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * (level + 2), &#34;pair&#34;, &#34;data&#34;))
            tmp1 = RefInt(0)
            tmp2 = RefInt(0)
            self.read_string_value(sb, first, tmp1)
            self.read_string_value(sb, second, tmp2)

    elif var_type_str == &#34;TypelessData&#34;:
        append = False
        size = self.reader.read_int()
        value = self.reader.read_bytes(size)
        i.v += 2
        sb.append(&#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * level, var_type_str, var_name_str))
        sb.append(&#34;{0}{1} {2} = {3}\r\n&#34;.format(&#34;\t&#34; * level, &#34;int&#34;, &#34;size&#34;, size))

    else:
        if i != len(members) and members[i + 1].type == &#34;Array&#34;:
            if (members[i + 1].meta_flag &amp; 0x4000) != 0:
                align = True
            append = False
            sb.append(
                &#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * level, var_type_str, var_name_str)
            )
            sb.append(&#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * (level + 1), &#34;Array&#34;, &#34;Array&#34;))
            size = self.reader.read_int()
            sb.append(
                &#34;{0}{1} {2} = {3}\r\n&#34;.format(
                    &#34;\t&#34; * (level + 1), &#34;int&#34;, &#34;size&#34;, size
                )
            )
            vector = get_members(members, level, i.v)
            i.v += len(vector) - 1
            vector = vector[3:]  # vector.RemoveRange(0, 3)
            for j in range(size):
                sb.append(&#34;{0}[{1}]\r\n&#34;.format(&#34;\t&#34; * (level + 2), j))
                tmp = RefInt(0)
                self.read_string_value(sb, vector, tmp)
        else:
            append = False
            sb.append(
                &#34;{0}{1} {2}\r\n&#34;.format(&#34;\t&#34; * level, var_type_str, var_name_str)
            )
            eclass = get_members(members, level, i.v)
            eclass.pop(0)  # .RemoveAt(0)
            i.v += len(eclass)
            j = RefInt(0)
            while j &lt; len(eclass):
                self.read_string_value(sb, eclass, j)
                j.v += 1

    if append:
        sb.append(
            &#34;{0}{1} {2} = {3}\r\n&#34;.format(
                &#34;\t&#34; * level, var_type_str, var_name_str, value
            )
        )
    if align:
        self.reader.align_stream()

    return sb</code></pre>
</details>
</dd>
<dt id="UnityPy.helpers.TypeTreeHelper.TypeTreeHelper.read_type_string"><code class="name flex">
<span>def <span class="ident">read_type_string</span></span>(<span>self, sb: list, members: list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_type_string(self, sb: list, members: list):
    i = RefInt(0)
    while i &lt; len(members):
        self.read_string_value(sb, members, i)
        i.v += 1
    return sb</code></pre>
</details>
</dd>
<dt id="UnityPy.helpers.TypeTreeHelper.TypeTreeHelper.read_typeless_data"><code class="name flex">
<span>def <span class="ident">read_typeless_data</span></span>(<span>self, i, align, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_typeless_data(self, i, align, *args):
    size = self.reader.read_int()
    value = self.reader.read_bytes(size)
    i.v += 2
    return value, align</code></pre>
</details>
</dd>
<dt id="UnityPy.helpers.TypeTreeHelper.TypeTreeHelper.read_u_type"><code class="name flex">
<span>def <span class="ident">read_u_type</span></span>(<span>self, members: list) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_u_type(self, members: list) -&gt; dict:
    i = RefInt(0)
    obj = {}
    while i.v &lt; len(members):
        member = members[i.v]
        obj[member.name] = self.read_value(members, i)
        i.v += 1
    return obj</code></pre>
</details>
</dd>
<dt id="UnityPy.helpers.TypeTreeHelper.TypeTreeHelper.read_value"><code class="name flex">
<span>def <span class="ident">read_value</span></span>(<span>self, members: list, _i) ‑> object</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_value(self, members: list, _i) -&gt; object:
    i = RefInt(_i) if type(_i) != RefInt else _i
    member = members[i.v]
    level = member.level
    var_type_str = member.type
    align = (member.meta_flag &amp; 0x4000) != 0

    value = self.READ.get(var_type_str)
    if value:
        value = value()
    else:
        value = self.READ2.get(var_type_str)
        if value:
            value, align = value(i, align, members, level)
        else:
            if i != len(members) and members[i.v + 1].type == &#34;Array&#34;:
                if (members[i.v + 1].meta_flag &amp; 0x4000) != 0:
                    align = True
                size = self.reader.read_int()
                vector = get_members(members, level, i)[3:]
                i.v += len(vector) + 2
                value = [self.read_value(vector, 0) for _ in range(size)]
            else:
                eclass = get_members(members, level, i)
                eclass.pop(0)
                i.v += len(eclass)
                j = RefInt(0)
                value = {}
                while j &lt; len(eclass):
                    classmember = eclass[j.v]
                    name = classmember.name
                    value[name] = self.read_value(eclass, j)
                    j.v += 1
    if align:
        self.reader.align_stream()
    return value</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="UnityPy.helpers" href="index.html">UnityPy.helpers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="UnityPy.helpers.TypeTreeHelper.get_members" href="#UnityPy.helpers.TypeTreeHelper.get_members">get_members</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="UnityPy.helpers.TypeTreeHelper.RefInt" href="#UnityPy.helpers.TypeTreeHelper.RefInt">RefInt</a></code></h4>
<ul class="">
<li><code><a title="UnityPy.helpers.TypeTreeHelper.RefInt.v" href="#UnityPy.helpers.TypeTreeHelper.RefInt.v">v</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UnityPy.helpers.TypeTreeHelper.TypeTreeHelper" href="#UnityPy.helpers.TypeTreeHelper.TypeTreeHelper">TypeTreeHelper</a></code></h4>
<ul class="two-column">
<li><code><a title="UnityPy.helpers.TypeTreeHelper.TypeTreeHelper.read_map" href="#UnityPy.helpers.TypeTreeHelper.TypeTreeHelper.read_map">read_map</a></code></li>
<li><code><a title="UnityPy.helpers.TypeTreeHelper.TypeTreeHelper.read_string" href="#UnityPy.helpers.TypeTreeHelper.TypeTreeHelper.read_string">read_string</a></code></li>
<li><code><a title="UnityPy.helpers.TypeTreeHelper.TypeTreeHelper.read_string_value" href="#UnityPy.helpers.TypeTreeHelper.TypeTreeHelper.read_string_value">read_string_value</a></code></li>
<li><code><a title="UnityPy.helpers.TypeTreeHelper.TypeTreeHelper.read_type_string" href="#UnityPy.helpers.TypeTreeHelper.TypeTreeHelper.read_type_string">read_type_string</a></code></li>
<li><code><a title="UnityPy.helpers.TypeTreeHelper.TypeTreeHelper.read_typeless_data" href="#UnityPy.helpers.TypeTreeHelper.TypeTreeHelper.read_typeless_data">read_typeless_data</a></code></li>
<li><code><a title="UnityPy.helpers.TypeTreeHelper.TypeTreeHelper.read_u_type" href="#UnityPy.helpers.TypeTreeHelper.TypeTreeHelper.read_u_type">read_u_type</a></code></li>
<li><code><a title="UnityPy.helpers.TypeTreeHelper.TypeTreeHelper.read_value" href="#UnityPy.helpers.TypeTreeHelper.TypeTreeHelper.read_value">read_value</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>